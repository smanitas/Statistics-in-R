# 1. Напишите функцию corr.calc, которая на вход получает data.frame с двумя количественными переменными, рассчитывает коэффициент корреляции Пирсона и возвращает вектор из двух значений: коэффициент корреляции и p - уровень значимости. 

corr.calc <- function(x){
  colnames(x) <- c("v1", 'v2')
  fit <- cor.test(x = x$v1, y = x$v2)
  return(c(fit$estimate, fit$p.value))
}

# 2. Напишите функцию filtered.cor которая на вход получает data.frame с  произвольным количеством переменных (как количественными, так и любых других типов), рассчитывает коэффициенты корреляции Пирсона между всеми парами количественных переменных и возвращает наибольшее по модулю значение коэффициента корреляции. (То есть функция может вернуть -0.9, если это наибольшая по модулю  корреляция). Гарантируется наличие в data.frame хотя бы двух количественных переменных.

filtered.cor <- function(df) {
  num_df <- df[, sapply(df, is.numeric)] # выбираем только количественные переменные с помощью sapply
  cor_matrix <- cor(num_df) # получаем матрицу корреляций
  diag(cor_matrix) <- 0 # устанавливаем значения на диагонали в ноль
  return(cor_matrix[which.max(abs(cor_matrix))])# возвращаем наибольшее по модулю значение коэффициента корреляции
}

# 3. Напишите функцию smart_cor, которая получает на вход dataframe с двумя количественными переменными. Проверьте с помощью теста Шапиро-Уилка, что данные в обеих переменных принадлежат нормальному распределению.
#Eсли хотя бы в одном векторе распределение переменной отличается от нормального (p - value меньше 0.05), то функция должна возвращать коэффициент корреляции Спирмена. (Числовой вектор из одного элемента).
#Если в обоих векторах распределение переменных от нормального значимо не отличается, то функция должна возвращать коэффициент корреляции Пирсона. 

smart_cor <- function(df) {
  col1 <- df[[1]]
  col2 <- df[[2]]
  
  # Проверяем нормальность распределения обеих переменных
  normality_test1 <- shapiro.test(col1)
  normality_test2 <- shapiro.test(col2)
  
  # Если обе переменные нормально распределены, используем коэффициент корреляции Пирсона
  if (normality_test1$p.value > 0.05 & normality_test2$p.value > 0.05) {
    return(cor(col1, col2))
  }
  # Если обе переменные не нормально распределены, используем коэффициент корреляции Спирмена
  else if (normality_test1$p.value < 0.05 & normality_test2$p.value < 0.05) {
    return(cor.test(col1, col2, method = "spearman")$estimate)
  }
  # Если только одна переменная не нормально распределена, используем коэффициент корреляции Спирмена
  else {
    return(cor.test(col1, col2, method = "spearman")$estimate)
  }
}

# 4. Воспользуемся уже знакомыми данными diamonds из библиотеки ggplot2. Только для бриллиантов класса Ideal (переменная cut) c числом карат равным 0.46 (переменная carat) постройте линейную регрессию, где в качестве зависимой переменной выступает price, в качестве предиктора - переменная  depth. Сохраните коэффициенты регрессии в переменную fit_coef.

# выбираем только бриллианты класса Ideal и с числом карат равным 0.46
diamonds_ideal <- subset(diamonds, cut == "Ideal" & carat == 0.46)

# строим линейную регрессию
fit <- lm(price ~ depth, data = diamonds_ideal)

# сохраняем коэффициенты регрессии
fit_coef <- coefficients(fit)

# 5. Напишите функцию regr.calc, которая на вход получает dataframe c двумя переменными.
#Если две переменные значимо коррелируют (p - уровень значимости для коэффициента корреляции Пирсона меньше 0.05), то функция строит регрессионную модель, где первая переменная - зависимая, вторая - независимая. Затем создает в dataframe новую переменную с назанием fit, где сохраняет предсказанные моделью значения зависимой переменной. В результате функция должна возвращать исходный dataframe с добавленной новой переменной fit.
#Если две переменные значимо не коррелируют, то функция возвращает строчку "There is no sense in prediction"

regr.calc <- function(df){
  corr <- cor.test(df[,1], df[,2])
  if (corr$p.value < 0.05) {    
    # строим линейную регрессию
    model <- lm(df[,1] ~ df[,2], data = df)
    df$fit <- predict(model)
    return(df)
  } else {
    # если корреляция не значима, возвращаем сообщение
    return("There is no sense in prediction")
  }
}

# 6. Постройте scatterplot по данным iris, сохранив его в переменную my_plot : #Ось X - переменная Sepal.Width
#Ось Y -  переменная Petal.Width
#Цвет точек - переменная Species
#Также добавьте линейное сглаживание для каждой группы наблюдений по переменной Species.

library(ggplot2)
my_plot <- ggplot(data = iris, aes(x = Sepal.Width, y = Petal.Width, color = Species)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)